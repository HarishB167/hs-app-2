React Router New 25.05.2023

- Introduction
* Setting up routes
* Handling errors
* Navigating between pages
* Dynamic routes
* Nested Routes
* Private Routes

- Setting up routing
* Install : npm i react-router-dom@6.10.0
* Create file as src/routing/routes.jsx
* Import : import {createBrowserRouter} from rrd
* Use as
const router = createBrowserRouter([
    { path: '/', element: <HomePage />},
    { path: '/users', element: <UserListPage />},
    { path: '/users/:id', element: <UserDetailPage />},
])
* Export : export default router
* In index.js
Replace <App/> with 
<RouterProvider router={router} />

- Navigation
* Using Link
Import {Link} from rrd
<Link to="/users">Users</Link>
* Using useNavigate hook
Import {useNavigate} from rrd
Getting navigate func : const navigate = useNavigate()
Using : func() { ...; navigate("/"); }
Use it only in useEffect and event handlers.

- Passing Data with Route Parameters
* In createBrowserRouter add
{ path: '/users/:id', element: <UserDetailPage /> },
* UserListPage create link
<Link to={`/users/${user.id}`}>{user.name}</Link>

- Getting Data about the Current Route
* In UserDetailPage
* Extract parameter values
useParams() : returns params object
const params = useParams()
params has {id: '1'}
* Access and update query string parameters
useSearchParams() : returns array 
of 2 elements [searchParams, setSearchParams]
const [searchParams, setSearchParams] = useSearchParams()
searchParams.toString() : name=Alice&age=25
searchParams.get('name') : Alice
setSearchParams has side effect, so it can be called in 
event handler or useEffect
* Access current location
useLocation() : returns object having
pathname: "/users/1"
search: "?name=Alice&age=25"
hash: ""
state: null
key: "default"

- Nested Routes
* In Layout.jsx add <Outlet /> as
Import from rrd
<NavBar />
<div>
    <Outlet />
</div>
Outlet is a placeholder for child component given by router
* Also add <Outlet /> in UsersPage file for second nesting.
* In routes.js change router as 
const router = createBrowserRouter([
    { 
    path: '/', 
    element: <Layout/>
    children: [
        { path: '', element: <HomePage />},
        { 
            path: 'users',
            element: <UsersPage />,
            children: [
               { path: ':id', element: <UserDetail/>},
            ]
         }
      ]
    },    
])
> Path of chilren should be relative to parent, so slash at start is removed.
> In children path: '' can be replaced with index: true, both ways are same.

- Styling the Active Link
* NavLink additionally applies active class as compared to Link, all other is same.
<NavLink />
* Using different word for active
className={({isActive}) => isActive ? 'diffActive nav-link' : 'nav-link'}

- Handling Errors
* In router for root element set
{path: '/' ..., errorElement: <ErrorPage />, children.... }
* Grabbing error
Import from rrd
useRouteError() : returns error object
const error = useRouteError()
* Differentiate b/w invalid route error and other errors
Import from rrd
Pass error obj from useRouteError()
isRouteErrorResponse(error) : true if invalid route error

- Private Routes
* Use <Navigate /> component import from rrd
* It is a wrapper around navigate function
* Used outside useEffect or event handlers
* Inside useEffect or event handlers, can use navigate function directly.
* If user not defined then
if (!user)
return <Navigate to="/login" />

- Layout Routes
* Grouping routes for enforcing layout or business rules.
* Create src/routing/PrivateRoutes.jsx as
const PrivateRoutes = () => {
   const {user} = useAuth();
   if (!user)
      return <Navigate to="/login" />;
   return <Outlet />;
}
* In routers create after root route as
const router = createBrowserRouter([
 { path: '/', ...},
 {
   element: <PrivateRoutes />,
   children: [ <move routes to be protected here> ]
 }
])

------------------------------------------------------------

Test driven development

- Structure
* What to test
If a component renders with or without props
How a component renders with state changes
How a componnet reacts to user interactions
* What not to test
Actual implementation : not testing actual sorting logic.
Third part libraries : they are already tested.
* Testing steps
> Render the component
> Get an element from the component and simulate any user interaction
> Write an assertion

- Setup
* Using create-react-app
* Libraries - jest and react-testing-library
* Ensure setupTests.js has
import '@testing-library/jest-dom';
import '@testing-library/jest-dom/extend-expect';
* In package.json
> change scripts.test : "react-scripts test --watchAll --coverage"
> For coverage threshold, add : 
    jest.coverageThreshold.global.lines : 80

- Writing test
* Folder containing component, create "__tests__" folder
* Create test element.test.jsx as :
import { render, screen } from '@testing-library/react'
import Element from '../components/Element';

test("Example 1 renders successfully", () => {
    render(<Element/>);

    const element = screen.getByText(/first test/i);

    expect(element).toBeInTheDocument();
})

- Using Mock data
* In test file declare test data
mockData = [...]
* Use in render as
render(<Element data={mockData}/>);

- Covering all branches
* Use different set of mock data to get different branches
* Write different test functions for that

- Test user interactions
* Install user-event library
npm i --save-dev @testing-library/user-event
* Test onClick of element
Checking onClick to be called

test("Email link click handler called", async () => {
    const mockHandleClick = jest.fn();
    render(<TestWithMockData 
                data={mockData} 
                displayUnorderedList={true}
                handleClick = {mockHandleClick}
          />)
    await userEvent.click(screen.getByText(/user@mail.com/i));
    expect(mockHandleClick).toHaveBeenCalled();
})

- Query input fields and buttons
* input type text : screen.getByRole('textbox')
* button : screen.getByRole('button')
* input by placeholder : screen.getByPlaceholderText(/enter name/i);
* input by label : screen.getByLabelText(/enter password/i);
* button by name : screen.getByRole('button', { name: /submit/i });
* input by label : screen.getByRole('textbox', { name: /enter password/i });

- Test state updates
* State change on button click
test("Toggle text visible", async () => {
    render(<TestingStateChange/>);
    await userEvent.click(screen.getByText(/toggle text/i));
    expect(screen.getByText(/text visible/i)).toBeInTheDocument();
})
* Test if element was added to list
> Use data-testid='record' for all records of list
test("Element added to the list", async () => {
    render(<TestingStateChange/>)
    expect(screen.getAllByTestId('record').length).toBe(3);

    await userEvent.click(screen.getByText(/add to list/i));
    expect(screen.getAllByTestId('record').length).toBe(4);
})
* Test if element was removed from list
test("Element removed from list", async () => {
    render(<TestingStateChange/>)
    await userEvent.click(screen.getByText(/remove from list/i));
    expect(screen.getAllByTestId('record').length).toBe(2);
})


- Test API Calls
* 